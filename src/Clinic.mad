import type { Maybe } from "Maybe"
import type { HandlerId } from "Terminal"
import type { Wish } from "Wish"

import type { Buffer } from "@/Buffer"

import Dict from "Dictionary"
import { noop } from "Function"
import IO from "IO"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"
import Process from "Process"
import Terminal from "Terminal"
import Tuple from "Tuple"
import { Wish } from "Wish"

import { ESC, clear, eraseAfterCursor, restoreCursor, saveCursor } from "@/Constants"



export alias Action a = a -> {}
export alias NullaryAction = Action {}
export alias Option = #[String, NullaryAction]
export alias ActionMap = Dictionary String NullaryAction

export defaultExit = () => {
  IO.putLine("ðŸ‘‹")
  Process.exit(0)
}

backspace :: Buffer String -> {}
export backspace = (buffer) => {
  buffer.pop()
  restoreCursor()
  eraseAfterCursor()
  IO.put(buffer.get())
}

clearKeyWatcher :: Maybe HandlerId -> {}
clearKeyWatcher = (handlerId) => {
  Terminal.disableTTYRawMode()
  pipe(
    map(Terminal.clearKeyPressedHandler),
  )(handlerId)
}

promptWithExit :: NullaryAction -> String -> Buffer String -> Wish String String
export promptWithExit = (exitAction, label, buffer) => {
  Terminal.enableTTYRawMode()
  IO.put(label ++ " ")
  saveCursor()
  keyWatch = Nothing
  return Wish(
    (_bad, _good) => {
      keyWatch := Just(
        Terminal.onKeyPressed(
          (seq) => {
            if (seq == ESC.CTRL_C) do {
              clearKeyWatcher(keyWatch)
              _bad("Quitting!")
              exitAction()
            } else if (seq == ESC.BACKSPACE) {
              backspace(buffer)
            } else if (seq == ESC.ENTER) do {
              clear()
              clearKeyWatcher(keyWatch)
              _good(buffer.get())
            } else do {
              IO.put(seq)
              buffer.push(seq)
            }
          },
        ),
      )
      return () => {}
    },
  )
}

export prompt = promptWithExit(defaultExit)

chooseActionWithExit :: NullaryAction -> ActionMap -> (List Option -> Integer -> String) -> {}
export chooseActionWithExit = (exitAction, actionMap, listRenderer) => {
  cursor = 0
  options = Dict.toList(actionMap)
  clear()
  saveCursor()
  max = List.length(options)
  draw = pipe(
    listRenderer(options),
    IO.put,
  )
  keyWatch = Nothing
  Terminal.enableTTYRawMode()
  draw(cursor)
  keyWatch := Just(
    Terminal.onKeyPressed(
      (seq) => {
        if (seq == ESC.CTRL_C) do {
          clearKeyWatcher(keyWatch)
          exitAction()
        } else if (seq == ESC.ARROW_UP || seq == ESC.ARROW_LEFT) do {
          cursor := cursor - 1 < 0 ? max - 1 : cursor - 1
        } else if (seq == ESC.ARROW_DOWN || seq == ESC.ARROW_RIGHT) do {
          cursor := cursor + 1 > max - 1 ? 0 : cursor + 1
        } else if (seq == ESC.ENTER) do {
          clearKeyWatcher(keyWatch)
          clear()
          pipe(
            List.nth(cursor),
            map(Tuple.snd),
            fromMaybe(noop),
            (fn) => fn(),
          )(options)
          restoreCursor()
          return {}
        }
        clear()
        draw(cursor)
      },
    ),
  )
}


export chooseAction = chooseActionWithExit(defaultExit)


chooseWithExit :: NullaryAction
  -> List String
  -> (List String -> Integer -> String)
  -> Wish String Integer
export chooseWithExit = (exitAction, choices, listRenderer) => Wish(
  (_bad, _good) => {
    cursor = 0
    clear()
    saveCursor()
    max = List.length(choices)
    draw = pipe(
      listRenderer(choices),
      IO.put,
    )

    Terminal.enableTTYRawMode()
    redraw = () => {
      clear()
      draw(cursor)
    }
    redraw()
    keyWatch = Nothing
    keyWatch := Just(
      Terminal.onKeyPressed(
        (seq) => {
          if (seq == ESC.CTRL_C) do {
            clearKeyWatcher(keyWatch)
            _bad("EXIT")
            exitAction()
          } else if (seq == ESC.ARROW_UP || seq == ESC.ARROW_LEFT) do {
            cursor := cursor - 1 < 0 ? max - 1 : cursor - 1
            redraw()
          } else if (seq == ESC.ARROW_DOWN || seq == ESC.ARROW_RIGHT) do {
            cursor := cursor + 1 > max - 1 ? 0 : cursor + 1
            redraw()
          } else if (seq == ESC.ENTER) do {
            clearKeyWatcher(keyWatch)
            restoreCursor()
            _good(cursor)
          } else {
            redraw()
          }
        },
      ),
    )
    return () => {}
  },
)

export choose = chooseWithExit(defaultExit)
